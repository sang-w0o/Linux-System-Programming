구조적 프로그래밍
======

<h2>구조적 프로그래밍</h2>

* shell에서는 기호를 사용할 수 없다.(redirection과 구별 불가)
* test명령어 : 파일 타입 비교 또는 값의 비교
  * if문을 사용할 때 자주 쓰인다.
  * test에 해당하는 내용이 참이면 if문을 수행한다.
  * test는 표현식이 참이면 0, 거짓이면 1을 반환한다.
  
<table>
  <tr>
    <td>STRING = STRING2</td>
    <td>The strings are equal.</td>
  </tr>
  <tr>
    <td>STRING != STRING2</td>
    <td>The strings are not equal.</td>
  </tr>
  <tr>
    <td>-n STRING</td>
    <td>The length of STRING is non-zero.</td>
  </tr>
  <tr>
    <td>-z STRING</td>
    <td>The lengh of STRING is zero.</td>
  </tr>
  <tr>
    <td>STRING = STRING2</td>
    <td>The strings are equal.</td>
  </tr>
  <tr>
    <td>INTEGER1 -eq INTEGER2</td>
    <td>INTEGER1 is equal to INTEGER2.</td>
  </tr>
  <tr>
    <td>INTEGER1 -ge INTEGER2</td>
    <td>INTEGER1 is greater than or equal to INTEGER2.</td>
  </tr>
  <tr>
    <td>INTEGER1 -gt INTEGER2</td>
    <td>INTEGER1 is greater than INTEGER2.</td>
  </tr>
  <tr>
    <td>INTEGER1 -le INTEGER2</td>
    <td>INTEGER1 is less than or equal to INTEGER2.</td>
  </tr>
  <tr>
    <td>INTEGER1 -lt INTEGER2</td>
    <td>INTEGER1 is less than INTEGER2.</td>
  </tr>
  <tr>
    <td>INTEGER1 -ne INTEGER2</td>
    <td>INTEGER1 is not equal to INTEGER2.</td>
  </tr>
  <tr>
    <td>FILE1 -ef FILE2</td>
    <td>FILE1 and FILE2 have the same device and inode numbers.</td>
  </tr>
  <tr>
    <td>FILE1 -nt FILE2</td>
    <td>FILE1 is newer than FILE2.</td>
  </tr>
  <tr>
    <td>FILE1 -ot FILE2</td>
    <td>FILE1 is older than FILE2.</td>
  </tr>
  <tr>
    <td>-d FILE</td>
    <td>FILE exists and is a directory.</td>
  </tr>
  <tr>
    <td>-e FILE</td>
    <td>FILE exists.</td>
  </tr>
  <tr>
    <td>-f FILE</td>
    <td>FILE exists and is a regular file.</td>
  </tr>
  <tr>
    <td>-L FILE</td>
    <td>FILE exists and is a symbolic link.</td>
  </tr>
  <tr>
    <td>( EXPRESSION )</td>
    <td>EXPRESSION is true.</td>
  </tr>
  <tr>
    <td>! EXPRESSION</td>
    <td>EXPRESSION is false.</td>
  </tr>
  <tr>
    <td>EXPRESSION1 -a EXPRESSION2</td>
    <td>Both EXPRESSION1 and EXPRESSION2 are true.</td>
  </tr>
  <tr>
    <td>EXPRESSION1 -o EXPRESSION2</td>
    <td>Either EXPRESSION1 or EXPRESSION2 is true.</td>
  </tr>
</table>

  ```sh
  #!/bin/bash
  # 사용자로부터 입력받은 숫자가 0인지를 판별하는 코드
  read -p "input integer :"
  
  if test "$REPLY" -eq 0 # if(REPLY==0)
  then
    echo "input is zero" # printf("input is zero.");
  fi   # 매크로의 #endif와 같이 if와 짝을 이루어줘야 한다.

  if test "$REPLY" -ne 0 # if(REPLY != 0)
  then
    echo "input is not zero"
  fi
  ```
  * 위 코드를 다음과 같이 작성할 수도 있다.
  ```sh
  read -p "input integer :"

  if test "$REPLY" -eq 0; then
    echo "zero"
  fi

  if test "$REPLY" -ne 0; then
    echo "input is not zero"
  fi
  ```

  * test 명령어가 반환하는 값의 의미.
  ```sh
  # if test... # test의 표현식이 참인 경우에 실행한다는 의미가 아니고,
          # test의 표현식이 참인 경우 종료 상태가 0으로 설정되고,
          # if문은 종료 상태를 보고 0이면 참으로 인식하여 실행합니다.
        
  ```
* shell에서는 test와 표현식의 복잡해질 수 있으므로 단축 표기법을 제공한다.
  * 형식 : __test 표현식 ==> [ 표현식 ]__
  * __주의__ : 대괄호의 앞 뒤에는 공백을 반드시 주어야 한다.
  * 예시 코드
  ```sh
  if test $REPLY -eq 0; then
    echo "zero"
  fi

  # 단축 표기법 사용 시
  if [ $REPLY -eq 0 ]; then
    echo "zero"
  fi
  ```

* shell에도 if문과 더불어 else문, else if문을 지원한다.
* 예시
```sh
read -p "input integer :"
if [ "$REPLY" -eq 0 ]; then
  echo "zero"
elif [ "$REPLY" -ge 0]; then
  echo "input is greater than zero"
else
  echo "input is less than zero"
fi
```

* 문자열 비교 
```sh
#!/bin/bash

# 비밀번호를 확인하는 코드
read -p "input password: "

if [ -z "$REPLY" ]; then
  echo "YOU SHOULD INPUT PASSWORD"
  exit 1
fi

read -p "confirm password: " pswd
if [ $pswd = $REPLY ]; then
  echo "Password is set."
else
  echo "Wrong password."
fi
```

* 파일 비교
```sh
#!/bin/bash

filename="~/.vimrc"
if [ -e "$filename" ]; then 
  echo "file exists."
else
  echo "file doesn't exist."
```

* 특정 dir가 존재하지 않을 경우, 그 dir를 생성하는 코드
```sh
#!/bin/bash

dirname="mysub"

if [ ! -d $dirname ]; then
  mkdir "$dirname"
fi
```
* 위 코드를 아래와 같이 단순화할 수 있다.
```sh
#!/bin/bash

dirname="subdir"
[ -d "$dirname" ] || mkdir "$dirname"
```

* Shell Script 실행 시, 명령행의 개수는 __#변수에 저장__ 된다.
```sh
[ "$#" -gt 3] || echo "3개 이상의 인자가 필요합니다."
``` 

* 입력받은 값이 숫자인지 아닌지 판별하는 기능은 bash에서 제공하지 않는다.
* 이를 판별하기 위해서는 정규표현식으로 비교해야 한다.
* test 명령어와 정규표현식을 같이 사용하기 위한 합성 명령어는 다음과 같다.
  * __[[ 표현식 ]]__
  * 정규 표현식에 대한 패턴 비교 : __문자열 =~ 패턴__
```sh
#!/bin/bash

if [[ "$str" =~ hello ]]; then
  echo "$str 안에는 hello 패턴이 있습니다."
fi
```
  * 사용자로부터 입력받은 값이 0인지 아닌지를 판별하는 코드
  ```sh
  #!/bin/bash

  read -p "input integer : " num

  if [[ ! "$num" =~ ^-?[[:digit:]]+$ ]]; then  # check if num is not an integer.
    echo "input is not integer!"
  elif [ "$num" -eq 0 ]; then
    echo "input is zero!"
  else
    echo "input is not zero!"
  fi  
  ```

* case문의 사용
  * 사용법 : __case $변수 in__
  * __ 0) 수행문 ;; 
    * 0) = case(0):
    * ;; = break;
  ```sh
  #!/bin/bash

  # system containing 3 types of menu.
  clear # clear screen

  echo "
  1. Chicken
  2. Pizza
  3. Bread
  0. Exit"

  read -p "* Select Menu: "

  # assume that user inputs valid menu number

  case $REPLY in   # switch(REPLY) {
  	0) exit 0    # case 0: exit(0);
  		;;       # break;
  	1) echo "You chose Chicken.";; 
  	# case 1: printf("You chose Chicken."); break;
  	2) echo "Your chose Pizza.";;
  	3) echo "You chose Bread.";;
    *) echo "Wrong menu number." exit;;
    # default: printf("Wrong menu number."); 
  esac
  ```

  * 예시 코드 2
  ```sh
  # If user inserts "A", execute case a.
  #!/bin/bash
  
  clear
  
  echo "
  a. Chicken
  b. Pizza
  c. Bread
  q. Exit"
 
  read -p "* Select Menu: "
 
  case $REPLY in
    q|Q) exit 0;;
    a|A) echo "You chose Chicken.";;
    b|B) echo "Your chose Pizza.";;
    c|C) echo "You chose Bread.";;
    *) echo "Wrong menu number." exit;;
  esac

  ```
  * case문에 사용되는 정규 표현식의 예시
    * a) : a와 완벽하게 일치하는 경우
    * a|A) : a 또는 A와 완벽하게 일치하는 경우
    * ???) : 정확히 3글자로 이루어진 단어인 경우
    * *.txt) : .txt로 끝나는 경우
    * *) : 모든 단어로 이루어진 경우 === default
      * 주의 : 가장 마지막에 사용하라. 위에 쓰면 다 이 경우에 해당한다.

* 반복문 : while문
  * 사용법 : while 표현식; do와 done으로 반복할 수행문 묶기
  * 예시 코드(1) - 무한루프로 문자열 찍기
  ```sh
  #!/bin/bash

  while true  # while(1)
  do  # {
    echo "Hello, world!" # printf("Hello, world!");
  done  # }
  ```
  * 예시 코드(2)
  ```sh
  while true; do  # while(1) {
    echo "Hello, world!" # printf("Hello, world!");
  done # }
  ```
  * 수식의 계산(1) : expr 명령어 사용 (4칙 연산만 지원)
    * 사용법 : expr 정수 연산자 정수
    * ex) expr 3 + 2  // 5 출력
    * ex) expr 3 / 2 // 1 출력
    * ex) expr 5 % 3 // 2 출력
    * 주의 : 곱셈의 *는 와일드카드로 사용되므로 __앞에 \를 붙여줘야 한다__. 
    * 주의 : 토큰과 토큰 사이에는 공백이 반드시 있어야 한다.
    * ex) expr 9 \* 9 // 81 출력
  * 수식의 계산(2) : $[수식]
    * 주의 : 이 연산자는 바로 치환되므로 결과는 echo를 통해 확인해야 한다.
    * ex) echo $[9 * 9] // 81 출력
    * ex) echo $[2 ** 5] // 32 출력 (2의 5승)
  * 수식의 계산(3)
  * 예시 코드(3) - 루프 카운터의 제어
  ```sh
  ```
