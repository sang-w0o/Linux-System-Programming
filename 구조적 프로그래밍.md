구조적 프로그래밍
======

<h2>구조적 프로그래밍</h2>

* shell에서는 기호를 사용할 수 없다.(redirection과 구별 불가)
* test명령어 : 파일 타입 비교 또는 값의 비교
  * if문을 사용할 때 자주 쓰인다.
  * test에 해당하는 내용이 참이면 if문을 수행한다.
  * test는 표현식이 참이면 0, 거짓이면 1을 반환한다.
  
<table>
  <tr>
    <td>STRING = STRING2</td>
    <td>The strings are equal.</td>
  </tr>
  <tr>
    <td>STRING != STRING2</td>
    <td>The strings are not equal.</td>
  </tr>
  <tr>
    <td>-n STRING</td>
    <td>The length of STRING is non-zero.</td>
  </tr>
  <tr>
    <td>-z STRING</td>
    <td>The lengh of STRING is zero.</td>
  </tr>
  <tr>
    <td>STRING = STRING2</td>
    <td>The strings are equal.</td>
  </tr>
  <tr>
    <td>INTEGER1 -eq INTEGER2</td>
    <td>INTEGER1 is equal to INTEGER2.</td>
  </tr>
  <tr>
    <td>INTEGER1 -ge INTEGER2</td>
    <td>INTEGER1 is greater than or equal to INTEGER2.</td>
  </tr>
  <tr>
    <td>INTEGER1 -gt INTEGER2</td>
    <td>INTEGER1 is greater than INTEGER2.</td>
  </tr>
  <tr>
    <td>INTEGER1 -le INTEGER2</td>
    <td>INTEGER1 is less than or equal to INTEGER2.</td>
  </tr>
  <tr>
    <td>INTEGER1 -lt INTEGER2</td>
    <td>INTEGER1 is less than INTEGER2.</td>
  </tr>
  <tr>
    <td>INTEGER1 -ne INTEGER2</td>
    <td>INTEGER1 is not equal to INTEGER2.</td>
  </tr>
  <tr>
    <td>FILE1 -ef FILE2</td>
    <td>FILE1 and FILE2 have the same device and inode numbers.</td>
  </tr>
  <tr>
    <td>FILE1 -nt FILE2</td>
    <td>FILE1 is newer than FILE2.</td>
  </tr>
  <tr>
    <td>FILE1 -ot FILE2</td>
    <td>FILE1 is older than FILE2.</td>
  </tr>
  <tr>
    <td>-d FILE</td>
    <td>FILE exists and is a directory.</td>
  </tr>
  <tr>
    <td>-e FILE</td>
    <td>FILE exists.</td>
  </tr>
  <tr>
    <td>-f FILE</td>
    <td>FILE exists and is a regular file.</td>
  </tr>
  <tr>
    <td>-L FILE</td>
    <td>FILE exists and is a symbolic link.</td>
  </tr>
  <tr>
    <td>( EXPRESSION )</td>
    <td>EXPRESSION is true.</td>
  </tr>
  <tr>
    <td>! EXPRESSION</td>
    <td>EXPRESSION is false.</td>
  </tr>
  <tr>
    <td>EXPRESSION1 -a EXPRESSION2</td>
    <td>Both EXPRESSION1 and EXPRESSION2 are true.</td>
  </tr>
  <tr>
    <td>EXPRESSION1 -o EXPRESSION2</td>
    <td>Either EXPRESSION1 or EXPRESSION2 is true.</td>
  </tr>
</table>
<hr/>
<h2>#1. 반복문</h2>

  ```sh
  #!/bin/bash
  # 사용자로부터 입력받은 숫자가 0인지를 판별하는 코드
  read -p "input integer :"
  
  if test "$REPLY" -eq 0 # if(REPLY==0)
  then
    echo "input is zero" # printf("input is zero.");
  fi   # 매크로의 #endif와 같이 if와 짝을 이루어줘야 한다.

  if test "$REPLY" -ne 0 # if(REPLY != 0)
  then
    echo "input is not zero"
  fi
  ```
  * 위 코드를 다음과 같이 작성할 수도 있다.
  ```sh
  read -p "input integer :"

  if test "$REPLY" -eq 0; then
    echo "zero"
  fi

  if test "$REPLY" -ne 0; then
    echo "input is not zero"
  fi
  ```

  * test 명령어가 반환하는 값의 의미.
  ```sh
  # if test... # test의 표현식이 참인 경우에 실행한다는 의미가 아니고,
          # test의 표현식이 참인 경우 종료 상태가 0으로 설정되고,
          # if문은 종료 상태를 보고 0이면 참으로 인식하여 실행합니다.
        
  ```
* shell에서는 test와 표현식의 복잡해질 수 있으므로 단축 표기법을 제공한다.
  * 형식 : __test 표현식 ==> [ 표현식 ]__
  * __주의__ : 대괄호의 앞 뒤에는 공백을 반드시 주어야 한다.
  * 예시 코드
  ```sh
  if test $REPLY -eq 0; then
    echo "zero"
  fi

  # 단축 표기법 사용 시
  if [ $REPLY -eq 0 ]; then
    echo "zero"
  fi
  ```

* shell에도 if문과 더불어 else문, else if문을 지원한다.
* 예시
```sh
read -p "input integer :"
if [ "$REPLY" -eq 0 ]; then
  echo "zero"
elif [ "$REPLY" -ge 0]; then
  echo "input is greater than zero"
else
  echo "input is less than zero"
fi
```

* 문자열 비교 
```sh
#!/bin/bash

# 비밀번호를 확인하는 코드
read -p "input password: "

if [ -z "$REPLY" ]; then
  echo "YOU SHOULD INPUT PASSWORD"
  exit 1
fi

read -p "confirm password: " pswd
if [ $pswd = $REPLY ]; then
  echo "Password is set."
else
  echo "Wrong password."
fi
```

* 파일 비교
```sh
#!/bin/bash

filename="~/.vimrc"
if [ -e "$filename" ]; then 
  echo "file exists."
else
  echo "file doesn't exist."
```

* 특정 dir가 존재하지 않을 경우, 그 dir를 생성하는 코드
```sh
#!/bin/bash

dirname="mysub"

if [ ! -d $dirname ]; then
  mkdir "$dirname"
fi
```
* 위 코드를 아래와 같이 단순화할 수 있다.
```sh
#!/bin/bash

dirname="subdir"
[ -d "$dirname" ] || mkdir "$dirname"
```

* Shell Script 실행 시, 명령행의 개수는 __#변수에 저장__ 된다.
```sh
[ "$#" -gt 3] || echo "3개 이상의 인자가 필요합니다."
``` 

* 입력받은 값이 숫자인지 아닌지 판별하는 기능은 bash에서 제공하지 않는다.
* 이를 판별하기 위해서는 정규표현식으로 비교해야 한다.
* test 명령어와 정규표현식을 같이 사용하기 위한 합성 명령어는 다음과 같다.
  * __[[ 표현식 ]]__
  * 정규 표현식에 대한 패턴 비교 : __문자열 =~ 패턴__
```sh
#!/bin/bash

if [[ "$str" =~ hello ]]; then
  echo "$str 안에는 hello 패턴이 있습니다."
fi
```
  * 사용자로부터 입력받은 값이 0인지 아닌지를 판별하는 코드
  ```sh
  #!/bin/bash

  read -p "input integer : " num

  if [[ ! "$num" =~ ^-?[[:digit:]]+$ ]]; then  # check if num is not an integer.
    echo "input is not integer!"
  elif [ "$num" -eq 0 ]; then
    echo "input is zero!"
  else
    echo "input is not zero!"
  fi  
  ```

* case문의 사용
  * 사용법 : __case $변수 in__
  * __ 0) 수행문 ;; 
    * 0) = case(0):
    * ;; = break;
  ```sh
  #!/bin/bash

  # system containing 3 types of menu.
  clear # clear screen

  echo "
  1. Chicken
  2. Pizza
  3. Bread
  0. Exit"

  read -p "* Select Menu: "

  # assume that user inputs valid menu number

  case $REPLY in   # switch(REPLY) {
  	0) exit 0    # case 0: exit(0);
  		;;       # break;
  	1) echo "You chose Chicken.";; 
  	# case 1: printf("You chose Chicken."); break;
  	2) echo "Your chose Pizza.";;
  	3) echo "You chose Bread.";;
    *) echo "Wrong menu number." exit;;
    # default: printf("Wrong menu number."); 
  esac
  ```

  * 예시 코드 2
  ```sh
  # If user inserts "A", execute case a.
  #!/bin/bash
  
  clear
  
  echo "
  a. Chicken
  b. Pizza
  c. Bread
  q. Exit"
 
  read -p "* Select Menu: "
 
  case $REPLY in
    q|Q) exit 0;;
    a|A) echo "You chose Chicken.";;
    b|B) echo "Your chose Pizza.";;
    c|C) echo "You chose Bread.";;
    *) echo "Wrong menu number." exit;;
  esac

  ```
  * case문에 사용되는 정규 표현식의 예시
    * a) : a와 완벽하게 일치하는 경우
    * a|A) : a 또는 A와 완벽하게 일치하는 경우
    * ???) : 정확히 3글자로 이루어진 단어인 경우
    * *.txt) : .txt로 끝나는 경우
    * *) : 모든 단어로 이루어진 경우 === default
      * 주의 : 가장 마지막에 사용하라. 위에 쓰면 다 이 경우에 해당한다.

* 반복문 : while문
  * 사용법 : while 표현식; do와 done으로 반복할 수행문 묶기
  * 예시 코드(1) - 무한루프로 문자열 찍기
  ```sh
  #!/bin/bash

  while true  # while(1)
  do  # {
    echo "Hello, world!" # printf("Hello, world!");
  done  # }
  ```
  * 예시 코드(2)
  ```sh
  while true; do  # while(1) {
    echo "Hello, world!" # printf("Hello, world!");
  done # }
  ```
  * 수식의 계산(1) : expr 명령어 사용 (4칙 연산만 지원)
    * 사용법 : expr 정수 연산자 정수
    * ex) expr 3 + 2  // 5 출력
    * ex) expr 3 / 2 // 1 출력
    * ex) expr 5 % 3 // 2 출력
    * 주의 : 곱셈의 *는 와일드카드로 사용되므로 __앞에 \를 붙여줘야 한다__. 
    * 주의 : 토큰과 토큰 사이에는 공백이 반드시 있어야 한다.
    * ex) expr 9 \* 9 // 81 출력
  * 수식의 계산(2) : $[수식]
    * 주의 : 이 연산자는 바로 치환되므로 결과는 echo를 통해 확인해야 한다.
    * ex) echo $[9 * 9] // 81 출력
    * ex) echo $[2 ** 5] // 32 출력 (2의 5승)
  * 수식의 계산(3) : $((수식))
    * ex) echo $((1+1))  // 2 출력
    * ex) echo $((7-3)) // 4 출력
    * ex) echo $((4/2)) // 2 출력
    * ex) echo $((5%4)) // 1 출력
    * ex) echo $((2**10)) // 1024 출력

  * 위 3가지 연산 방법의 피연산자로 변수가 올 수 있는지를 확인해보자.
  ```sh
  n1=10
  n2=20
  age=0  # 0이라는 문자가 age에 저장됨을 의미.

  # expr 연산
  expr $n1 + $n2  # 30 출력
  expr ++$n1 # 오류 발생 (단항 연산자에 대해서는 동작하지 않음)

  # 대괄호 연산
  echo $[$n1 + $n2]  # 30 출력
  echo $[n1 + n2]  # 30 출력 (수식 내부에서 $연산자를 사용하지 않아도 된다.)
  echo $[age = age + 1]  # 1 출력
  echo $[age += 1]  # 2 출력
  echo $[++age]  # 3 출력

  # 이중 소괄호 연산
  echo $((age = age + 1))  # 1 출력
  echo $((age += 1))  # 2 출력
  echo $(( ++age ))  # 3 출력
  ```

  * 예시 코드(3) - 루프 카운터의 제어
  ```sh
  #!/bin/bash

  cnt=1

  while [ "$cnt" -le 5 ]; do  # while(cnt <= 5) {
      echo "$cnt: hello, world"  # printf("%d: hello, world", cnt);
      ((++cnt))  # ++cnt;
  done   # }

  # 또다른 방법
  count=1
  while ((count <= 5)); do
    echo "$cnt: hello, world"
    ((++cnt))
  done
  ```

  * 예시 코드(4) - 1부터 입력받은 수까지의 합 출력
  ```sh
  #!/bin/bash
  
  read -p "insert integer which is bigger than 1:" num

  if [ ! "$num" =~ ^[123456789][[:digit:]]*$ ]; then
    echo "WRONG VALUE"
    exit 1
  fi

  tot=0
  cnt=0
  while [ "$cnt" -le $sum ]; do
    ((tot += cnt))
    ((++cnt))
  done

  echo "total : $tot"
  ```
  * bash에서도 while문을 제어하기 위한 break, continue를 제공한다.
  * 예시 코드(5) - 1부터 100까지의 자연수 중 짝수만 저장하는 스크립트
  ```sh
  #!/bin/bash

  cnt=0
  sum=0

  while true; do
    ((++cnt))
    if ((cnt>100)); then
        break;
    fi

    if (( (cnt%2) != 0)); then
        continue;
    else
        ((sum+=cnt))
    fi
  done

  echo "$sum"  
  ```

* 반복문 : until문
  * while은 표현식이 참인 경우에 루프를 실행햐지만, until은 표현식이 거짓인 경우에 루프를 실행한다.
  * 사용방법 : until 표현식; do ... done
  * 예시 코드(6) - 1부터 100까지 자연수의 합
  ```sh

  cnt=1
  sum=0

  until ((cnt > 100)); do
    ((sum += cnt))
    ((++cnt))
  done

  echo "$sum"
  ```

* 반복문 : for문 (list 기반 반복문)
  * 사용방법 : for 변수명 in 리스트 do ... done
  * 예시 코드(7)
  ```sh
  for var in 0 1 2 3 4 5 6 7 8 9
  do
    echo "$var : hello, world"
  done

  # 위 코드는 아래와 같이 사용할 수 있다.
  for var in {0..9}; do
    echo "$var : hello, world"
  done

  # 현재 dir내의 파일 출력
  for fname in *; do
    echo "file name : $fname"
  done
  ```
  * 예시 코드(8) : for로 1이상의 자연수로 입력받아 1부터 입력값까지의 총합 출력
  ```sh
  # 오류 처리 생략
  read -p "insert a number: "
  sum=0

  for num in {1..$REPLY}; do
    ((sum += num))
  done

  echo "$sum"

  # 위 코드는 오류가 발생한다.
  # 중괄호 확장에는 변수를 사용할 수 없기 때문이다.
  # 중괄호 확장에는 상수만 사용할 수 있다.
  ```
  * __중괄호 확장에는 변수를 사용할 수 없다.__
  * 따라서 __seq__ 명령어를 사용하도록 한다.
    * seq 사용법 : seq 1 10 --> 1~10의 정수 출력
      * seq 10 -1 1 --> 10부터 1까지 -1씩 증분하며 출력
      * ex) seq 1 2 15 --> 1부터 15까지 짝수만 출력
  ```sh
  * 예시 코드(9)
  #!/bin/bash
  read -p "insert a number: "
  sum=0
  
  for num in $(seq $REPLY); do
    ((sum += num))
  done

  echo "$sum"
  ```

* 반복문 : C언어와 유사한 for loop
  * 사용법 : for ((expr1; expr2; expr3)); do ... done
  * 예시 코드(10)
  ```sh
  for ((i = 0; i < 5; i++)); do
    echo "$i : Hello, world"
  done
  ```

* 반복문의 중첩 예시 (주로 사용 X)
```sh
#!/bin/bash

for (( i = 2; i < 10; ++i)); do
    for (( j = 1; j < 10; ++j )); do
        printf " %d * %d = %d\n" $i $j $((i*j))
    done
    echo   # 개행 용도
done
```
* 달력 출력해보기
```sh
echo " Su Mo Tu We Th Fr Sa"

for day in {1..31}; do
    printf "%3d" $day
    ((( day % 7 ) == 0 )) && echo
done
```
<hr/>

<h2>#2. 함수</h2>

* bash에서 프로그램 실행 시 주어지는 인수를 (C에서는 argument에 해당)   
  positional parameter라 한다.
* pre-defined variable(미리 지정된 매개변수)
  * __#__ : 스크립트 실행 시의 인자의 개수 저장
  * __REPLY__ : read 명령어가 가지는 내장 객체, 읽어온 값 저장
  * __0__ : 실행된 스크립트의  이름
  * __1~9__ : Optional parameter
  * __@__ : 위치 매개변수 전체를 저장하고 있는 내장 변수
    * 2자리 이상의 위치 매개 변수를 참조할 때에는 ${ }로 묶어줘야 한다.
* 예시 코드 (1)
```sh
echo $1 $2 $3 $4 $5 $6 $7 $8 $9 $10
# $10은 $1의 값에 0을 붙이는 것으로 해석한다.
# 이럴 경우에 ${ }를 사용하는 것이다.
```
* 예시 코드 (2) : 인자로 들어온 매개변수 출력
```sh
# 방법 (1)
while [ -n "$1" ]; do
    echo "$1"
    shift
done
# shift : 위치 매개변수 전체를 왼쪽으로 1칸씩 shift 한다.

# 방법 (2)
for arg in $@; do
    echo "$arg"
done
```

* 예시 코드 (3) : a, b, c 옵션만을 받는 sh파일 구현
  * 파일명 : test.sh
  * 사용법 : ./test.sh -a -b -c (그 이외의 옵션 사용 불가)
  ```sh
  #!/bin/bash

  while [ -n "$1" ]; do
    case ${1#-} in
        a) echo "option a";;
        b) echo "option b";;
        c) echo "option c";;
        *) echo "usage: ./text.sh [-a] [-b] [-c]" exit;;
    esac
    shift
  done
  ```

  * 하지만 __ls -al__ 와 같이 옵션을 연결하여 사용하는 경우도 처리해야 한다.
  * 이를 구현하기 위한 명령어로 이미 __getopt__ 명령어가 제공된다.
  ```sh
  #!/bin/bash
  
  

  ```